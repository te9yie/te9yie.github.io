{"pageProps":{"data":[{"id":"2021-03-11","content":"[[WebAssembly]]でマウスイベントの処理もやってみた。\n\nhttps://github.com/te9yie/wasm-mouse-event/\n\n<iframe\n    title=\"wasm-mouse-event\"\n    width=\"430\"\n    height=\"230\"\n    src=\"https://te9yie.github.io/wasm-mouse-event/\">\n</iframe>\n\n楽しくなってきた。\n"},{"id":"2021-03-10","content":"[[webpack]]のことを調べて最新の[[webpack]]でも[[WebAssembly]]が使えるようになった。[The `wasm-bindgen` Guide](https://rustwasm.github.io/docs/wasm-bindgen/)を読みながら、アニメーションするものを作ってみた。\n\nhttps://github.com/te9yie/wasm-bounce-ball\n\n<iframe\n    title=\"wasm-bounce-ball\"\n    width=\"430\"\n    height=\"230\"\n    src=\"https://te9yie.github.io/wasm-bounce-ball\">\n</iframe>\n\n---\n\n`Window.requestAnimationFrame()`の呼び出しが難解。\n\n[[JavaScript]]でもクロージャを作って、その中で自分自身を渡すみたいな作りになる。\n\n```javascript\nconst step = (now) => {\n    ...\n    window.requestAnimationFrame(step);\n};\nwindow.requestAnimationFrame(step);\n```\n\n[[Rust]]だとこんな感じ。クロージャの中で自分自身を使いたいから先に変数は定義しておいて、登録用とクロージャ用に`Rc`で共有して、あとで代入するから`RefCell`にして――みたいな。\n\n```rust\nlet f = Rc::new(RefCell::new(None));\nlet ff = Rc::clone(&f);\n*ff.borrow_mut() = Some(Closure::wrap(Box::new(move |now| {\n    ...\n    request_animation_frame(f.borrow().as_ref().unwrap());\n}) as Box<dyn FnMut(f64)>));\nrequest_animation_frame(ff.borrow().as_ref().unwrap());\n```\n\nマウスやキーボードなどの入力も取れるようになると、もう少し面白いものも作れそうだ。\n"},{"id":"2021-03-08","content":"[[Rust]]で[[WebAssembly]]を生成しようにも、[[webpack]]の挙動が理解できてなくて意味が分からない。一旦[[webpack]]使わずに、[[Rust]]から`wasm`を生成し、それを[[HTML]]から読み込むだけのところから始めてみる。\n\n[[Rust]]のクレートとして`wasm-bindgen`を使う。これは、[[Rust]]と[[JavaScript]]の橋渡しをしてくれる。あと`web-sys`。これを使うと[[Rust]]から[[DOM]]を操作できるようになる。\n\n`lib.rs`:\n\n```rust\nuse wasm_bindgen::prelude::*;\nuse wasm_bindgen::JsCast;\n\n#[wasm_bindgen(start)]\npub fn main() {\n    let window = web_sys::window().unwrap();\n    let document = window.document().unwrap();\n    let canvas = document.get_element_by_id(\"canvas\").unwrap();\n    let canvas = canvas.dyn_into::<web_sys::HtmlCanvasElement>().unwrap();\n    let context = canvas.get_context(\"2d\").unwrap();\n    let context = context\n        .unwrap()\n        .dyn_into::<web_sys::CanvasRenderingContext2d>()\n        .unwrap();\n\n    context.set_font(\"100% sans-serif\");\n    context.fill_text(\"Hello WASM!\", 10.0, 20.0).unwrap();\n\n    context.set_fill_style(&\"red\".into());\n    context.fill_rect(20.0, 30.0, 40.0, 40.0);\n\n    context.set_fill_style(&\"green\".into());\n    context.fill_rect(40.0, 50.0, 40.0, 40.0);\n}\n```\n\n`Cargo.toml`:\n\n```toml\n[package]\nname = \"hello-wasm-canvas\"\nversion = \"0.1.0\"\nauthors = [\"te9yie <te9yie@users.noreply.github.com>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nwasm-bindgen = \"*\"\n\n[dependencies.web-sys]\nversion = \"*\"\nfeatures = [\n    \"CanvasRenderingContext2d\",\n    \"Document\",\n    \"Element\",\n    \"HtmlCanvasElement\",\n    \"Window\",\n]\n```\n\nビルドしてみる。\n\n```bash\n$ wasm-pack build --target web\n```\n\n`pkg`ディレクトリが生成される。\n\n```bash\npkg\n├── hello_wasm_canvas.d.ts\n├── hello_wasm_canvas.js\n├── hello_wasm_canvas_bg.wasm\n├── hello_wasm_canvas_bg.wasm.d.ts\n└── package.json\n```\n\n[[TypeScript]]用の型情報も生成されるんだな。\n\nこれを読み込む[[HTML]]を書いてみる。\n\n`index.html`:\n\n```html\n<html>\n    <body>\n        <script type=\"module\">\n            import init from \"./pkg/hello_wasm_canvas.js\";\n            const run = async () => {\n                await init();\n            }\n            run();\n        </script>\n        <canvas id=\"canvas\" />\n    </body>\n</html>\n```\n\n適当にサーバを立てて確認してみる。\n\n```bash\n$ npx serve\n```\n\n動いた！\n\n[[webpack]]でこんな感じの[[HTML]]を生成したりしてたんだな。それだけなのになんでバージョン4と5であんなに挙動が変わるんだろう。[[webpack]]の`html-webpack-plugin`と`wasm-pack-plugin`あたりを調べてみようか。どうせならバージョン5の方で動かしてみたい。\n"}]},"__N_SSG":true}